#include <hw/lcd.h>
#include <hw/kpd.h>
#include <core/fs.h>
#include <core/lib.h>
#include <core/menu.h>
#include <core/bitmap.h>
#include <apps/madmedia.h>


const file_type_t file_types[] = {  //file type setup
    {"suxx", "Test file generated by the fs test function", FILE_TYPE_TEST, "Test files"},
    {"bin", "Binary file", FILE_TYPE_SYSTEM, "Binary files"},
    {"bmp", "Bitmap file", FILE_TYPE_IMAGE, "Image files"},
    {"wav", "wav sound file", FILE_TYPE_SOUND, "Sound Files"},
    {"txt", "wav sound file", FILE_TYPE_TEXT, "Text files"}
};                              //file type setup
unsigned int debugon = 0;
#define DEBUG(x) if(debugon == 1)\
{\
	lcd_clr();\
	lcd_render_text ( 0, 0, x, 1 );\
	lcd_to_screen_hw ();\
	ksleep(5);\
}
#define DEBUGINT(x, y) if(debugon == 1)\
{\
	unsigned char buf[16];\
	sprintf ( buf, "%d", y );\
	lcd_clr();\
	lcd_render_text ( 0, 0, x, 1 );\
	lcd_render_text ( 0, 8, buf, 1 );\
	lcd_to_screen_hw ();\
	ksleep(2);\
}



int sel_file_type = 0;
unsigned int menu_select;

void *
strplus ( void *ptr, int amount )
{                               //function
    return ( void * ) ptr + amount;
}                               //function


void
drawmedia (  )
{                               //function
    lcd_draw_bitmap ( 0, 0, &bmp_mheader );
}                               //function

void
drawmediamenu (  )
{                               //function
    lcd_draw_bitmap ( 23, 6, &bmp_mmusic );
    lcd_draw_bitmap ( 23, 16, &bmp_mmovies );
    lcd_draw_bitmap ( 23, 26, &bmp_mpics );
    lcd_draw_bitmap ( 23, 36, &bmp_mconf );
    switch ( menu_select )
    {                           //switch
        case 1:
            lcd_draw_bitmap ( 23, 6, &bmp_mmusichot );
            lcd_draw_bitmap ( 54, 7, &bmp_mmusicicon );
            break;
        case 2:
            lcd_draw_bitmap ( 23, 16, &bmp_mmovieshot );
            lcd_draw_bitmap ( 54, 7, &bmp_mmoviesicon );
            break;
        case 3:
            lcd_draw_bitmap ( 23, 26, &bmp_mpicshot );
            lcd_draw_bitmap ( 54, 7, &bmp_mpicsicon );
            break;
        case 4:
            lcd_draw_bitmap ( 23, 36, &bmp_mconfhot );
            lcd_draw_bitmap ( 54, 7, &bmp_mconficon );
            break;
        default:
            break;
    }                           //switch
}                               //function






int
open_bitmap ( const char *name )
{                               //function
    int len = 0;
    int read = 0;
    unsigned char *buf = NULL;
    FILE *f = NULL;
    len = get_length ( name );

    buf = ( unsigned char * ) malloc ( len );
    f = fs_fopen ( ( void * ) name, "r" );
    if ( !f )
    {                           //if f
        fs_fclose ( f );
        return 0;
    }                           //if f
    read = fs_fread ( buf, 1, len, f );
    if ( read != len )
    {                           //if read
        fs_fclose ( f );
        return 0;
    }                           //if read

    fs_fclose ( f );
    ui_draw_scrolltext ( buf );
    free ( buf );
}                               //function


int
get_length ( const char *name )
{                               //function
    int len = 0;
    int read = 0;
    unsigned char *buf = NULL;
    FILE *f = NULL;
    len = fs_getsize ( ( void * ) name );

    buf = ( unsigned char * ) malloc ( len );
    f = fs_fopen ( ( void * ) name, "r" );
    if ( !f )
    {                           //if
        fs_fclose ( f );
        return 0;
    }                           //if
    read = fs_fread ( buf, 1, len, f );
    fs_fclose ( f );
    free ( buf );
    return read;
}                               //function

long
get_file_type ( const char *name )
{                               //function
    char *str = NULL;
    int c = 0;
    str = strplus ( ( void * ) name, instr ( name, "." ) );
    while ( file_types[c].ext )
    {                           //while
        if ( strcomp ( file_types[c].ext, str ) )
        {                       //if
            sel_file_type = c;
            return file_types[c].type;
        }                       //if
        c++;
    }                           //while
    return FILE_TYPE_UNKNOWN;
}                               //function










int
strcomp ( const char *str1, const char *str2 )
{                               //strcomp
    unsigned int i = 0;
    unsigned int len1 = strlen ( str1 );
    unsigned int len2 = strlen ( str2 );
    if ( len1 != len2 )
        return 0;


    while ( str1[i] == str2[i] && i < len1 )
    {                           //while
        i++;
        if ( str1[i] != str2[i] )
            return 0;


    }                           // while
    return 1;
}                               //strcomp




int
instr ( const char *str1, const char *str2 )
{                               //function
    //returns the position of a character in a string
    unsigned int i = 0;
    int len;
    len = strlen ( str1 );
    if ( strlen ( str2 ) > 1 )
        return 0;


    while ( i < len )
    {                           //while
        if ( str1[i] == str2[0] )
            return i + 1;
        i++;
    }                           //while
}                               //function


void *
draw_files_list ( long _filter, const char *title, const char *navtxt )
{                               //function
    int c = 0;
    int i = 0;
    int a = 0;

    int amt;
    int fcount = fs_countfiles (  );
    DEBUGINT ( "fcount", fs_countfiles (  ) );
  start:
    i = 0;
    if ( fcount > 3 )
    {                           //Fcount > 3
        //  lcd_clr();
        lcd_fontsettings ( FONT_SIZED );
        lcd_set_font ( 2 );

        lcd_render_text ( ( 84 - lcd_get_text_width ( ( void * ) navtxt ) ) / 2, 40, ( void * ) navtxt, 1 );
        lcd_render_text ( 14, 13 + 8 * 0, "LOADING...", 1 );
        lcd_render_text ( 0, 0, ( void * ) title, 1 );
        DEBUG ( "text done" );
        char *fentries[fcount - 1];
        fcount = fcount - 2;
        DEBUG ( "*fentries[fcount - 1]" );
        DEBUGINT ( "*while(c < fcount + 1)", fcount + 1 );
        while ( c < fcount + 1 )
        {                       //while

            DEBUGINT ( "while(c < fcount + 1)", c );
            DEBUG ( fs_listfile ( c + 1 ) );

            if ( _filter != FILE_TYPE_ALL )
            {                   //if not all files
                DEBUG ( fs_listfile ( c + 1 ) );

                if ( get_file_type ( fs_listfile ( c + 1 ) ) == _filter )
                {               //_filter
                    fentries[i - 1] = fs_listfile ( c + 1 );
                    DEBUGINT ( "filter i++", i );
                    i++;
                }               //_filter
            }                   //if not all files
            else
            {
                fentries[i - 1] = fs_listfile ( c + 1 );
                DEBUGINT ( "filter all i++", i );
                i++;
            }
            DEBUGINT ( "c++", c );
            c++;
        }                       //while
        DEBUG ( "some text" );
        //lcd_render_text_ml ( 84 - lcd_get_text_width((void *)file_types[sel_file_type].ext), 0, (void *)file_types[sel_file_type].ext, 1, AL_RIGHT );
        DEBUG ( "some text" );



        lcd_to_screen (  );
        lcd_set_font ( 0 );
        DEBUG ( "last element null" );

        fentries[i - 1] = NULL; //last element is NULL
        DEBUG ( "Draw menu" );
        a = media_menu_dropdown ( fentries, a );

        lcd_set_font ( 0 );
        lcd_fontsettings ( FONT_SYSTEM );
        DEBUG ( "returning" );

        if ( a != -1 )
        {
            DEBUG ( fentries[a] );
            return fentries[a];
        }
        else
        {
            DEBUG ( "NO FILE SELECTED" );
            return "NO FILE SELECTED";
        }
        sleep ( 1 );
        ksleep ( 4 );
    }                           //Fcount > 3
    else
    {                           //else
        lcd_render_text ( 14, 13 + 8 * 0, "No files!", 1 );
        ksleep ( 100 );
        return NULL;
    }                           //else

}                               //function


void
show_selected (  )
{                               //function
    char *f;
    lcd_clr (  );
    drawmedia (  );
    lcd_to_screen (  );
    //debugon = 1;     //for testing pourposes only

    switch ( menu_select )
    {                           //switch
        case 1:
            f = /*DEBUG*/ ( draw_files_list ( FILE_TYPE_TEST, "", "Select" ) );
            break;
        case 2:
            f = /*DEBUG*/ ( draw_files_list ( FILE_TYPE_ALL, "", "Select" ) );
            break;
        case 3:
            f = /*DEBUG*/ ( draw_files_list ( FILE_TYPE_IMAGE, "", "Select" ) );
            break;
        case 4:
            f = /*DEBUG*/ ( draw_files_list ( FILE_TYPE_IMAGE, "", "Select" ) );
            break;
        default:
            break;
    }                           //switch
//     debugon = 0; //for testing pourposes only
}                               //function







int
mediamain (  )
{                               //function
    char key;
    menu_select = 1;
    while ( 1 )
    {                           //while
        lcd_clr (  );
        drawmedia (  );
        drawmediamenu (  );
        lcd_to_screen (  );

        kpd_wait_keypress (  );
        key = kpd_getkey (  );
        kpd_wait_release (  );
        switch ( key )
        {                       //switch key
            case 1:
                break;
            case 2:
                break;
            case 3:
                break;
            case 4:
                break;
            case 5:
                break;
            case 6:
                break;
            case 7:
                break;
            case 8:
                break;
            case 9:
                break;
            case 0:
                break;
            case 10:           //*
                break;
            case 12:           //#
                break;
            case KPD_CANCEL:
                return 0;
                break;
            case KPD_DWNARROW:
                if ( menu_select > 4 )
                    menu_select = 1;
                else
                    menu_select++;
                break;
            case KPD_UPARROW:
                if ( menu_select < 1 )
                    menu_select = 4;
                else
                    menu_select--;
                break;
            case KPD_SOFTBTN1:
                show_selected (  );
                break;
            default:
                break;
        }                       //switch key
    }                           //while
}                               //function

void
media_dropdown_print ( char **entries, int pos, int first )
{                               //function
    int i, height, num = 0;

    while ( entries[num] != NULL )
        num++;

    height = MIN ( num, 3 );


    lcd_draw_rect ( 0, 13, 84, 12 + 8 * height, 0 );
    for ( i = 0; i < height; i++ )
    {                           //for height
        lcd_render_text ( 1, 13 + 8 * i, entries[lib_mod ( first + i, num )], 1 );
    }                           //for height
    lcd_draw_rect ( 0, 13 + 8 * ( pos - first ), 84, 13 + 7 + 8 * ( pos - first ), 2 );
    lcd_to_screen (  );
}                               //function


int
media_menu_dropdown ( char **entries, int pos )
{                               //Function
    int ignoresleep = 0;
    int num = 0, first = MAX ( 0, pos - 1 );
    unsigned char key, prevkey = 0xFF;

    while ( entries[num] != NULL )
        num++;

    while ( first + 2 >= num && first )
        first--;

    while ( 1 )
    {                           //while 1
        media_dropdown_print ( entries, pos, first );

        if ( !ignoresleep )
            kpd_wait_release_x ( 1000 );
        else
            kpd_wait_release_x ( 300 );
        ignoresleep = 0;

        kmsleep ( 200 );
        key = kpd_getkey (  );

        if ( key != 0xFF && key == prevkey )
            ignoresleep = 1;
        prevkey = key;

        switch ( key )
        {                       //switch key
            case KPD_UPARROW:
                if ( pos )
                    pos--;
                else
                    pos = num - 1;
                break;
            case KPD_DWNARROW:
                if ( pos == num - 1 )
                    pos = 0;
                else
                    pos++;
                break;
            case KPD_SOFTBTN1:
                return ( pos );
                break;
            case KPD_CANCEL:
                return ( -1 );
                break;
            default:
                break;
        }                       //switch key
        if ( pos < first )
            first = pos;
        else if ( pos > first + 2 )
            first = pos - 2;
    }                           //while

}                               //function
